
"""
mG-Ring Model
"""

#using Comrade
#using VLBISkyModels
#using Distributions

# sky model
function skyRing(θ, p)
    (;r, w, ma, mp, τ, ξτ, f, 
	  σg, τg, ξg, xg, yg) = θ
    α = ma.*cos.(mp .- ξτ)
    β = ma.*sin.(mp .- ξτ)
    ring = smoothed(modify(MRing(α, β), Stretch(r, r*(1+τ)), Rotate(ξτ)), w)
    g = modify(Gaussian(), Stretch(σg, σg*(1+τg)), Rotate(ξg), Shift(xg, yg))
    # Add a large-scale gaussian to deal with the over-resolved mas flux
    #g = modify(Gaussian(), Stretch(μas2rad(500.0), μas2rad(500.0)), Renormalize(ftot * fg))
    return f*ring + (1-f)*g
end


"""
    KrangModel(inclination, metric, mesh)

Creates a generic Krang model that obeys the ComradeBase interface. 

## Arguments
- `inclination`: The inclination angle of the screen in radians.
- `metric`: The metric used for the model, e.g., Krang.Kerr(spin)
- `mesh`: The emitting object that you will ray-trace, i.e. a dual cone model.
"""
struct KrangModel{T, Mt, Ms} <: VLBISkyModels.AbstractModel
    inclination::T
    metric::Mt
    mesh::Ms
end

# This is an image based model that won't have an analytic Fourier transform
ComradeBase.visanalytic(::Type{<:KrangModel}) = ComradeBase.NotAnalytic()
# We can ray-trace this model at a point
ComradeBase.imanalytic(::Type{<:KrangModel}) = ComradeBase.IsAnalytic()
# Since we aren't fitting polarization we don't need to worry about it
ComradeBase.ispolarized(::Type{<:KrangModel}) = ComradeBase.NotPolarized()

# Intensity at each pixel
function ComradeBase.intensity_point(m::KrangModel{T}, p) where {T}
    px = Krang.IntensityPixel(m.metric, -T(p.X), T(p.Y), m.inclination)
    i = Krang.render(px, m.mesh)
    return i  # Stokes I
end

function skyKrang(θ, metadata)
    """
    Use Krang model with Comrade sky function interface.
    θ contains parameters to fit.

    Comrade expects that any model function must accept a named tuple and
    returns an object that implements the
    [VLBISkyModels Interface](https://ehtjulia.github.io/VLBISkyModels.jl/stable/interface/)

    For Comrade to specify a `SkyModel`, we need to define a function that
    accepts two arguments. The first argument `θ` is a NamedTuple of
    parameters. The second argument `p` or 'metadata' is a NamedTuple or Tuple
    of fixed arguments needed to define the model fully.
    For geometric models we don't need `p`.
    """

    (;a, pa, mod, incl, θs, p1, p2, rpeak, χ, ι, βv, spec, η) = θ

    met = Krang.Kerr(a)
    T = typeof(a)  # Assume the type of `a` is what we want.
    vel = Krang.SVector(βv, (T(π) / 2), χ)  # velocity field

    subimgs = (0, 1)  # We want to ray-trace the 0 and 1 subimages
    magfield1 = Krang.SVector(sin(ι) * cos(η), sin(ι) * sin(η), cos(ι))
    material1 = Krang.ElectronSynchrotronPowerLawIntensity(magfield1..., vel..., spec, rpeak, p1, p2, subimgs)
    geometry1 = Krang.ConeGeometry(θs)
    mesh1 = Krang.Mesh(geometry1, material1)

    magfield2 = Krang.SVector(-sin(ι) * cos(η), -sin(ι) * sin(η), cos(ι))
    material2 = Krang.ElectronSynchrotronPowerLawIntensity(magfield2..., vel..., spec, rpeak, p1, p2, subimgs)
    geometry2 = Krang.ConeGeometry(T(π)-θs)
    mesh2 = Krang.Mesh(geometry2, material2)
    
    scene = Krang.Scene((mesh1, mesh2))
    kr = KrangModel(incl, met, scene)
    # We include a rotation to rotate the PA of the spin axis
    # We include a stretch to model the M/D (mod) ratio. For Sgr A* you may want to fix this.
    # TODO Sgr A* - fixed and fitted mod
    m = modify(kr, Stretch(μas2rad(mod)), Rotate(pa))
    # Finally we want to renormalize the total flux to be 1.0 (we could also fit this)
    return RenormFlux(m, one(T))
end

"""
    RenormFlux(model, flux)

Creates a model that renormalizes the flux of the given model `m` to the value `flux`. 
This is useful for models that do not have a fixed flux, such as those generated by ray-tracing.
"""
struct RenormFlux{M, T} <: ComradeBase.AbstractModel
    model::M
    flux::T
end
ComradeBase.visanalytic(::Type{<:RenormFlux{M}}) where {M} = ComradeBase.visanalytic(M)
ComradeBase.imanalytic(::Type{<:RenormFlux{M}}) where {M} = ComradeBase.imanalytic(M)

function ComradeBase.flux(m::RenormFlux)
    return m.flux
end

function ComradeBase.intensitymap_analytic!(img::IntensityMap, m::RenormFlux)
    ComradeBase.intensitymap_analytic!(img, m.model)
    pimg = baseimage(img)
    pimg .*= flux(m) ./sum(pimg)
    return nothing
end

function ComradeBase.intensitymap_analytic!(img::IntensityMap{T,N,D,
                                                  <:ComradeBase.AbstractRectiGrid{D,
                                                                                  <:ThreadsEx{S}}},
                                m::RenormFlux) where {T,N,D,S}
    ComradeBase.intensitymap_analytic!(img, m.model)
    pimg = baseimage(img)
    pimg .*= flux(m) ./ sum(pimg)
    return nothing
end

# Hack so that if you modify a model renorm flux actually scales it to the correct value
rescalefluxfac(::Comrade.VLBISkyModels.ModelModifier{T}) where {T} = one(T)
rescalefluxfac(m::Comrade.VLBISkyModels.Renormalize) = m.scale
function Comrade.VLBISkyModels.ModifiedModel(m::RenormFlux, t::NTuple{N}) where {N}
    f = prod(ntuple(Val(N)) do i
            return rescalefluxfac(t[i])
    end)
    return RenormFlux(m.model, m.flux * f)
end